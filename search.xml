<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>axios与ajax区别</title>
    <url>/2021/09/11/axios/</url>
    <content><![CDATA[<p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中</p>
<span id="more"></span>

<h4 id="1、区别"><a href="#1、区别" class="headerlink" title="1、区别"></a>1、区别</h4><p>axios是通过promise实现对ajax技术的一种封装，就像jQuery实现ajax封装一样。简单来说： ajax技术实现了网页的局部数据刷新，axios实现了对ajax的封装。axios是ajax ajax不止axios。</p>
<h4 id="2、代码对比"><a href="#2、代码对比" class="headerlink" title="2、代码对比"></a>2、代码对比</h4><p>axios</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">axios</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/getUsers&#x27;</span>,<br>	<span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>	<span class="hljs-attr">responseType</span>: <span class="hljs-string">&#x27;json&#x27;</span>, <span class="hljs-comment">// 默认的</span><br>	<span class="hljs-attr">data</span>: &#123;<br>        <span class="hljs-comment">//&#x27;a&#x27;: 1,</span><br>        <span class="hljs-comment">//&#x27;b&#x27;: 2,</span><br>    &#125;<br>	&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response);<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>);<br>	&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>	&#125;）<br></code></pre></td></tr></table></figure>

<p>ajax</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">$.<span class="hljs-title function_">ajax</span>(&#123;<br>	<span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/getUsers&#x27;</span>,<br>	<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>	<span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span>,<br>	<span class="hljs-attr">data</span>: &#123;<br>        <span class="hljs-comment">//&#x27;a&#x27;: 1,</span><br>        <span class="hljs-comment">//&#x27;b&#x27;: 2,</span><br>	&#125;,<br>	<span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response)；<br>	&#125;<br>	&#125;)<br></code></pre></td></tr></table></figure>

<h4 id="3、优缺点"><a href="#3、优缺点" class="headerlink" title="3、优缺点"></a>3、优缺点</h4><p>ajax：</p>
<p>本身是针对MVC的编程,不符合现在前端MVVM的浪潮，基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案<br>JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理。</p>
<p>axios:</p>
<p>从 node.js 创建 http 请求，支持 Promise API，客户端支持防止CSRF，提供了一些并发请求的接口（重要，方便了很多的操作）</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客搭建</title>
    <url>/2021/05/18/hexo-agin/</url>
    <content><![CDATA[<p>Hexo是一套快速、简洁且高效的博客框架</p>
<span id="more"></span>

<h2 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1.安装Git"></a>1.安装Git</h2><p><a href="https://git-scm.com/">官方下载地址</a></p>
<h2 id="2-安装Node-js"><a href="#2-安装Node-js" class="headerlink" title="2.安装Node.js"></a>2.安装Node.js</h2><p>在 Windows 环境下安装 Node.js 非常简单，仅须<a href="https://nodejs.org/en/">下载安装</a>文件并执行即可完成安装。</p>
<h2 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3.安装hexo"></a>3.安装hexo</h2><p>利用 npm 命令即可安装。（在任意位置点击鼠标右键，选择Git bash）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">npm install -g hexo<br></code></pre></td></tr></table></figure>

<p>可以通过以下命令查看hexo的版本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">hexo version<br></code></pre></td></tr></table></figure>

<h4 id="3-1创建Hexo文件夹"><a href="#3-1创建Hexo文件夹" class="headerlink" title="3.1创建Hexo文件夹"></a>3.1创建Hexo文件夹</h4><p>安装完成后，在合适的磁盘内新建一个文件夹作为博客目录 （如E:\Hexo），执行以下指令(<code>在E:\Hexo文件夹内点击鼠标右键，选择Git bash</code>）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">hexo init<br></code></pre></td></tr></table></figure>

<h4 id="3-2安装依赖包"><a href="#3-2安装依赖包" class="headerlink" title="3.2安装依赖包"></a>3.2安装依赖包</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">npm install<br></code></pre></td></tr></table></figure>

<h4 id="3-3本地查看"><a href="#3-3本地查看" class="headerlink" title="3.3本地查看"></a>3.3本地查看</h4><p>我们已经搭建起本地的hexo博客了，输入下列内容进行本地缓存。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">hexo g<br>hexo s<br></code></pre></td></tr></table></figure>

<p>输入以下内容到浏览器<code>localhost:4000</code>即可查看本地效果。</p>
<h2 id="4-将博客部署到Github"><a href="#4-将博客部署到Github" class="headerlink" title="4.将博客部署到Github "></a>4.将博客部署到Github </h2><h4 id="4-1注册Github账号"><a href="#4-1注册Github账号" class="headerlink" title="4.1注册Github账号"></a>4.1注册Github账号</h4><p>已有账号可以跳过。没有的，<a href="https://github.com/">请在此进行注册</a>，这里就不介绍了。</p>
<h4 id="4-2创建repository"><a href="#4-2创建repository" class="headerlink" title="4.2创建repository"></a>4.2创建repository</h4><p>在自己<a href="https://github.com/">Github</a>主页右上角，点击加号， 创建一个新的repository。</p>
<h4 id="4-3部署"><a href="#4-3部署" class="headerlink" title="4.3部署"></a>4.3部署</h4><p>编辑<code>_config.yml</code>(在E:\Hexo下)。将<code>repository</code>换成你刚才新建的地址。<br>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">deploy:<br>  <span class="hljs-built_in">type</span>: git<br>  repository: https://github.com/laustar/laustar.github.io.git<br>  branch: master<br></code></pre></td></tr></table></figure>

<h2 id="5-配置SSH"><a href="#5-配置SSH" class="headerlink" title="5.配置SSH"></a>5.配置SSH</h2><h4 id="5-1创建SSH"><a href="#5-1创建SSH" class="headerlink" title="5.1创建SSH"></a>5.1创建SSH</h4><p>在正式部署之前，新用户需要设置 <a href="https://help.github.com/en/articles/connecting-to-github-with-ssh">SSH</a>。</p>
<h4 id="5-2安装上传工具"><a href="#5-2安装上传工具" class="headerlink" title="5.2安装上传工具"></a>5.2安装上传工具</h4><p>安装部分模块，执行下面的命令。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure>

<p>在第一次使用Git时，需要用户名和邮箱两个信息  。具体通过以下命令设置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">git config --<span class="hljs-keyword">global</span> user.name <span class="hljs-string">&quot;你的用户名&quot;</span><br>git config --<span class="hljs-keyword">global</span> user.email <span class="hljs-string">&quot;你的邮箱&quot;</span><br></code></pre></td></tr></table></figure>

<p>最后输入以下命令上传即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">hexo clean<br>hexo g<br>hexo d<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux安装mysql</title>
    <url>/2023/11/25/linux-mysql/</url>
    <content><![CDATA[<p>MySQL数据库服务是一个完全托管的数据库服务,可使用世界上最受欢迎的开源数据库来部署云原生应用程序。</p>
<span id="more"></span>

<h2 id="1-设置MySQL软件源"><a href="#1-设置MySQL软件源" class="headerlink" title="1. 设置MySQL软件源"></a>1. 设置MySQL软件源</h2><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb http://repo.mysql.com/apt/debian/ buster mysql-5.7&quot;</span> | <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/mysql.list <br></code></pre></td></tr></table></figure>

<h2 id="2-创建数据库存储目录"><a href="#2-创建数据库存储目录" class="headerlink" title="2. 创建数据库存储目录"></a>2. 创建数据库存储目录</h2><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> -p /data/mysql/prod<br></code></pre></td></tr></table></figure>

<h2 id="3-导入密钥更新软件源并安装数据库"><a href="#3-导入密钥更新软件源并安装数据库" class="headerlink" title="3.导入密钥更新软件源并安装数据库"></a>3.导入密钥更新软件源并安装数据库</h2><blockquote>
<p>安装前请使用命令<code>dpkg -l | grep mariadb</code>检查操作系统是否安装了mariadb数据库，如果安装了请使用命令<code>apt remove mariadb* -y</code>进行卸载之后再执行下面命令</p>
<p><strong>注意：</strong>在新的APT版本中apt-key命令已被弃用，并建议使用trusted.gpg.d目录管理密钥文件。为了解决”Warning: apt-key is deprecated”警告，您可以在安装完数据库后用以下命令来解决：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">apt install gpg -y &amp;&amp; gpg --dearmor --<span class="hljs-built_in">yes</span> -o /etc/apt/trusted.gpg.d/mysql.gpg /etc/apt/trusted.gpg<br></code></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">apt install gnupg -y &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-----BEGIN PGP PUBLIC KEY BLOCK-----</span><br><span class="hljs-string">Version: SKS 1.1.6</span><br><span class="hljs-string">Comment: Hostname: pgp.mit.edu</span><br><span class="hljs-string"></span><br><span class="hljs-string">mQINBGG4urcBEACrbsRa7tSSyxSfFkB+KXSbNM9rxYqoB78u107skReefq4/+Y72TpDvlDZL</span><br><span class="hljs-string">mdv/lK0IpLa3bnvsM9IE1trNLrfi+JES62kaQ6hePPgn2RqxyIirt2seSi3Z3n3jlEg+mSdh</span><br><span class="hljs-string">AvW+b+hFnqxo+TY0U+RBwDi4oO0YzHefkYPSmNPdlxRPQBMv4GPTNfxERx6XvVSPcL1+jQ4R</span><br><span class="hljs-string">2cQFBryNhidBFIkoCOszjWhm+WnbURsLheBp757lqEyrpCufz77zlq2gEi+wtPHItfqsx3rz</span><br><span class="hljs-string">xSRqatztMGYZpNUHNBJkr13npZtGW+kdN/xu980QLZxN+bZ88pNoOuzD6dKcpMJ0LkdUmTx5</span><br><span class="hljs-string">z9ewiFiFbUDzZ7PECOm2g3veJrwr79CXDLE1+39Hr8rDM2kDhSr9tAlPTnHVDcaYIGgSNIBc</span><br><span class="hljs-string">YfLmt91133klHQHBIdWCNVtWJjq5YcLQJ9TxG9GQzgABPrm6NDd1t9j7w1L7uwBvMB1wgpir</span><br><span class="hljs-string">RTPVfnUSCd+025PEF+wTcBhfnzLtFj5xD7mNsmDmeHkF/sDfNOfAzTE1v2wq0ndYU60xbL6/</span><br><span class="hljs-string">yl/Nipyr7WiQjCG0m3WfkjjVDTfs7/DXUqHFDOu4WMF9v+oqwpJXmAeGhQTWZC/QhWtrjrNJ</span><br><span class="hljs-string">AgwKpp263gDSdW70ekhRzsok1HJwX1SfxHJYCMFs2aH6ppzNsQARAQABtDZNeVNRTCBSZWxl</span><br><span class="hljs-string">YXNlIEVuZ2luZWVyaW5nIDxteXNxbC1idWlsZEBvc3Mub3JhY2xlLmNvbT6JAlQEEwEIAD4W</span><br><span class="hljs-string">IQSFm+jXxYb1OEMLGcJGe5QtOnm9KQUCYbi6twIbAwUJA8JnAAULCQgHAgYVCgkICwIEFgID</span><br><span class="hljs-string">AQIeAQIXgAAKCRBGe5QtOnm9KUewD/992sS31WLGoUQ6NoL7qOB4CErkqXtMzpJAKKg2jtBG</span><br><span class="hljs-string">G3rKE1/0VAg1D8AwEK4LcCO407wohnH0hNiUbeDck5x20pgS5SplQpuXX1K9vPzHeL/WNTb9</span><br><span class="hljs-string">8S3H2Mzj4o9obED6Ey52tTupttMF8pC9TJ93LxbJlCHIKKwCA1cXud3GycRN72eqSqZfJGds</span><br><span class="hljs-string">aeWLmFmHf6oee27d8XLoNjbyAxna/4jdWoTqmp8oT3bgv/TBco23NzqUSVPi+7ljS1hHvcJu</span><br><span class="hljs-string">oJYqaztGrAEf/lWIGdfl/kLEh8IYx8OBNUojh9mzCDlwbs83CBqoUdlzLNDdwmzu34Aw7xK1</span><br><span class="hljs-string">4RAVinGFCpo/7EWoX6weyB/zqevUIIE89UABTeFoGih/hx2jdQV/NQNthWTW0jH0hmPnajBV</span><br><span class="hljs-string">AJPYwAuO82rx2pnZCxDATMn0elOkTue3PCmzHBF/GT6c65aQC4aojj0+Veh787QllQ9FrWbw</span><br><span class="hljs-string">nTz+4fNzU/MBZtyLZ4JnsiWUs9eJ2V1g/A+RiIKu357Qgy1ytLqlgYiWfzHFlYjdtbPYKjDa</span><br><span class="hljs-string">ScnvtY8VO2Rktm7XiV4zKFKiaWp+vuVYpR0/7Adgnlj5Jt9lQQGOr+Z2VYx8SvBcC+by3XAt</span><br><span class="hljs-string">YkRHtX5u4MLlVS3gcoWfDiWwCpvqdK21EsXjQJxRr3dbSn0HaVj4FJZX0QQ7WZm6WLkCDQRh</span><br><span class="hljs-string">uLq3ARAA6RYjqfC0YcLGKvHhoBnsX29vy9Wn1y2JYpEnPUIB8X0VOyz5/ALv4Hqtl4THkH+m</span><br><span class="hljs-string">mMuhtndoq2BkCCk508jWBvKS1S+Bd2esB45BDDmIhuX3ozu9Xza4i1FsPnLkQ0uMZJv30ls2</span><br><span class="hljs-string">pXFmskhYyzmo6aOmH2536LdtPSlXtywfNV1HEr69V/AHbrEzfoQkJ/qvPzELBOjfjwtDPDeP</span><br><span class="hljs-string">iVgW9LhktzVzn/BjO7XlJxw4PGcxJG6VApsXmM3t2fPN9eIHDUq8ocbHdJ4en8/bJDXZd9eb</span><br><span class="hljs-string">QoILUuCg46hE3p6nTXfnPwSRnIRnsgCzeAz4rxDR4/Gv1Xpzv5wqpL21XQi3nvZKlcv7J1IR</span><br><span class="hljs-string">VdphK66De9GpVQVTqC102gqJUErdjGmxmyCA1OOORqEPfKTrXz5YUGsWwpH+4xCuNQP0qmre</span><br><span class="hljs-string">Rw3ghrH8potIr0iOVXFic5vJfBTgtcuEB6E6ulAN+3jqBGTaBML0jxgj3Z5VC5HKVbpg2DbB</span><br><span class="hljs-string">/wMrLwFHNAbzV5hj2Os5Zmva0ySP1YHB26pAW8dwB38GBaQvfZq3ezM4cRAo/iJ/GsVE98dZ</span><br><span class="hljs-string">EBO+Ml+0KYj+ZG+vyxzo20sweun7ZKT+9qZM90f6cQ3zqX6IfXZHHmQJBNv73mcZWNhDQOHs</span><br><span class="hljs-string">4wBoq+FGQWNqLU9xaZxdXw80r1viDAwOy13EUtcVbTkAEQEAAYkCPAQYAQgAJhYhBIWb6NfF</span><br><span class="hljs-string">hvU4QwsZwkZ7lC06eb0pBQJhuLq3AhsMBQkDwmcAAAoJEEZ7lC06eb0pSi8P/iy+dNnxrtiE</span><br><span class="hljs-string">Nn9vkkA7AmZ8RsvPXYVeDCDSsL7UfhbS77r2L1qTa2aB3gAZUDIOXln51lSxMeeLtOequLME</span><br><span class="hljs-string">V2Xi5km70rdtnja5SmWfc9fyExunXnsOhg6UG872At5CGEZU0c2Nt/hlGtOR3xbt3O/Uwl+d</span><br><span class="hljs-string">ErQPA4BUbW5K1T7OC6oPvtlKfF4bGZFloHgt2yE9YSNWZsTPe6XJSapemHZLPOxJLnhs3VBi</span><br><span class="hljs-string">rWE31QS0bRl5AzlO/fg7ia65vQGMOCOTLpgChTbcZHtozeFqva4IeEgE4xN+6r8WtgSYeGGD</span><br><span class="hljs-string">RmeMEVjPM9dzQObf+SvGd58u2z9f2agPK1H32c69RLoA0mHRe7Wkv4izeJUc5tumUY0e8Ojd</span><br><span class="hljs-string">enZZjT3hjLh6tM+mrp2oWnQIoed4LxUw1dhMOj0rYXv6laLGJ1FsW5eSke7ohBLcfBBTKnMC</span><br><span class="hljs-string">BohROHy2E63Wggfsdn3UYzfqZ8cfbXetkXuLS/OM3MXbiNjg+ElYzjgWrkayu7yLakZx+mx6</span><br><span class="hljs-string">sHPIJYm2hzkniMG29d5mGl7ZT9emP9b+CfqGUxoXJkjs0gnDl44bwGJ0dmIBu3ajVAaHODXy</span><br><span class="hljs-string">Y/zdDMGjskfEYbNXCAY2FRZSE58tgTvPKD++Kd2KGplMU2EIFT7JYfKhHAB5DGMkx92HUMid</span><br><span class="hljs-string">sTSKHe+QnnnoFmu4gnmDU31i</span><br><span class="hljs-string">=Xqbo</span><br><span class="hljs-string">-----END PGP PUBLIC KEY BLOCK-----&quot;</span> &gt;&gt; /data/mysql.key &amp;&amp; apt-key add /data/mysql.key &amp;&amp; <span class="hljs-built_in">rm</span> -rf /data/mysql.key &amp;&amp; apt update &amp;&amp; apt-get install mysql-server -y &amp;&amp; <span class="hljs-built_in">chown</span> -R mysql:mysql /data/mysql/prod/<br></code></pre></td></tr></table></figure>

<h2 id="4-修改配置文件"><a href="#4-修改配置文件" class="headerlink" title="4. 修改配置文件"></a>4. 修改配置文件</h2><p>修改<code>/etc/mysql/my.cnf</code>配置文件，可根据实际情况修改对应的配置，例如存储位置<code>datadir</code>之类的参数，如下快捷命令可直接执行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;!includedir /etc/mysql/conf.d/</span><br><span class="hljs-string"></span><br><span class="hljs-string">[mysqld]</span><br><span class="hljs-string"># 基础信息配置</span><br><span class="hljs-string">port=3306</span><br><span class="hljs-string">character_set_server=utf8mb4</span><br><span class="hljs-string">datadir=/data/mysql/prod</span><br><span class="hljs-string">socket=/var/run/mysqld/mysqld.sock</span><br><span class="hljs-string">symbolic-links=0</span><br><span class="hljs-string">log-error=/var/log/mysql/error.log</span><br><span class="hljs-string">pid-file=/var/run/mysqld/mysqld.pid</span><br><span class="hljs-string">sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</span><br><span class="hljs-string"># 区分大小写配置 0：表名敏感字段不敏感 1：表名不敏感字段敏感 2：都不敏感</span><br><span class="hljs-string">lower_case_table_names=0</span><br><span class="hljs-string"></span><br><span class="hljs-string"># 连接配置</span><br><span class="hljs-string">max_connections=3000</span><br><span class="hljs-string">max_user_connections=3000</span><br><span class="hljs-string">max_connect_errors=100000</span><br><span class="hljs-string">max_allowed_packet=1G</span><br><span class="hljs-string">collation_server=utf8mb4_general_ci</span><br><span class="hljs-string">table_open_cache=8000</span><br><span class="hljs-string"></span><br><span class="hljs-string"># 日志配置</span><br><span class="hljs-string">expire_logs_days=30</span><br><span class="hljs-string">binlog_format=mixed</span><br><span class="hljs-string">slow_query_log=ON</span><br><span class="hljs-string">slow_query_log_file=/data/mysql/prod/slow.log</span><br><span class="hljs-string">long_query_time=3</span><br><span class="hljs-string">log_queries_not_using_indexes=on</span><br><span class="hljs-string"></span><br><span class="hljs-string"># innodb配置</span><br><span class="hljs-string">innodb_file_per_table=1</span><br><span class="hljs-string">innodb_buffer_pool_size=8G</span><br><span class="hljs-string">innodb_log_file_size=1024M</span><br><span class="hljs-string">innodb_log_buffer_size=64M</span><br><span class="hljs-string"></span><br><span class="hljs-string"># 集群配置 主从或主主只需要修改ID和偏移量即可</span><br><span class="hljs-string">server-id=1</span><br><span class="hljs-string">auto-increment-offset=1 </span><br><span class="hljs-string">auto-increment-increment=2</span><br><span class="hljs-string">log-bin=mysql-bin</span><br><span class="hljs-string">relay-log=localhost-relay-bin</span><br><span class="hljs-string">relay-log-index=slave-relay-bin.index</span><br><span class="hljs-string"></span><br><span class="hljs-string"># 需要同步的库 网上教程多是逗号隔开这是错误的配置方式</span><br><span class="hljs-string">binlog-do-db=cloudpivot</span><br><span class="hljs-string">binlog-do-db=h3yun_report</span><br><span class="hljs-string"></span><br><span class="hljs-string">[mysql]</span><br><span class="hljs-string">default_character_set=utf8mb4</span><br><span class="hljs-string">[client]</span><br><span class="hljs-string">default_character_set=utf8mb4&#x27;</span> &gt; /etc/mysql/my.cnf<br></code></pre></td></tr></table></figure>

<h2 id="5-启动MySQL并设置开机自启动"><a href="#5-启动MySQL并设置开机自启动" class="headerlink" title="5. 启动MySQL并设置开机自启动"></a>5. 启动MySQL并设置开机自启动</h2><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">systemctl restart mysql &amp;&amp; systemctl <span class="hljs-built_in">enable</span> mysql<br></code></pre></td></tr></table></figure>

<h2 id="6-登录MySQL"><a href="#6-登录MySQL" class="headerlink" title="6. 登录MySQL"></a>6. 登录MySQL</h2><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">mysql -u root -p<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Mysql5.7</tag>
      </tags>
  </entry>
  <entry>
    <title>初识微服务组件</title>
    <url>/2021/07/07/java-springcloud-1/</url>
    <content><![CDATA[<p>何为微服务？微服务是一种用于构建应用的架构方案。微服务架构有别于更为传统的单体式方案，可将应用拆分成多个核心功能。每个功能都被称为一项服务，可以单独构建和部署，这意味着各项服务在工作（和出现故障）时不会相互影响。</p>
<span id="more"></span>

<h4 id="1、网关-Spring-Cloud-Gateway"><a href="#1、网关-Spring-Cloud-Gateway" class="headerlink" title="1、网关(Spring Cloud Gateway)"></a>1、网关(Spring Cloud Gateway)</h4><h5 id="1-1-Gateway是什么"><a href="#1-1-Gateway是什么" class="headerlink" title="1.1 Gateway是什么"></a>1.1 Gateway是什么</h5><p>Spring Cloud Gateway是Spring Cloud官方推出的第二代网关框架，取代Zuul网关。网关作为流量的，在微服务系统中有着非常作用，网关常见的功能有路由转发、权限校验、限流控制等作用。</p>
<h5 id="1-2-特征"><a href="#1-2-特征" class="headerlink" title="1.2 特征"></a>1.2 特征</h5><ul>
<li>基于Spring 5，Reactor(模式) 和 SpringBoot 2.0</li>
<li>能够在任何请求属性上匹配路由</li>
<li>断言和过滤器是特定于路由的</li>
<li>Hystrix 断路器集成</li>
<li>SpringCloud DiscoveryClient集成</li>
<li>易于编写断言和过滤器</li>
<li>请求速率限制</li>
<li>路径重写</li>
</ul>
<h4 id="2、注册中心-Eureka"><a href="#2、注册中心-Eureka" class="headerlink" title="2、注册中心(Eureka)"></a>2、注册中心(Eureka)</h4><h5 id="2-1-Eureka简介"><a href="#2-1-Eureka简介" class="headerlink" title="2.1 Eureka简介"></a>2.1 Eureka简介</h5><p>Eureka是Netflix开发的服务发现框架，本身是一个基于REST的服务，主要用于定位运行在AWS域中的中间层服务，以达到负载均衡和中间层服务故障转移的目的。Spring Cloud将它集成在其子项目spring-cloud-netflix中，以实现Spring Cloud的服务发现功能。</p>
<h4 id="3、ELK统一日志系统"><a href="#3、ELK统一日志系统" class="headerlink" title="3、ELK统一日志系统"></a>3、ELK统一日志系统</h4><h5 id="ELK简介"><a href="#ELK简介" class="headerlink" title="ELK简介"></a>ELK简介</h5><p>ELK是Elasticsearch、Logstash、Kibana的缩写。</p>
<ul>
<li>Elasticsearch 是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。</li>
<li>Logstash 是一个完全开源的工具，他可以对你的日志进行收集、过滤，并将其存储供以后使用（如，搜索）。</li>
<li>Kibana 也是一个开源和免费的工具，它Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助您汇总、分析和搜索重要数据日志</li>
</ul>
<h5 id="为什么做日志系统"><a href="#为什么做日志系统" class="headerlink" title="为什么做日志系统"></a>为什么做日志系统</h5><p>通常当系统发生故障时，需要登录到各个服务器上去查找故障原因。在没有日志系统的情况下，首先需要定位处理请求的服务器，如果这台服务器部署了多个实例，则需要去每个应用实例的日志目录下去找日志文件。这对于我们排查故障以及及时找到故障原因，造成了比较大的麻烦。因此，如果我们能把这些日志集中管理，并提供集中检索功能，不仅可以提高诊断的效率，同时对系统情况有个全面的理解。<br>总的来说有一下三点</p>
<ul>
<li>数据查找：通过检索日志信息，定位相应的 bug，找出解决方案。</li>
<li>服务诊断：通过对日志信息进行统计、分析，了解服务器的负荷和服务运行状态</li>
<li>数据分析：可以做进一步的数据分析。</li>
</ul>
<h4 id="4、消息队列集群"><a href="#4、消息队列集群" class="headerlink" title="4、消息队列集群"></a>4、消息队列集群</h4><h5 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h5><p>消息队列，英文全名MessageQueue（MQ）指的是在程序之间传送的数据，而消息队列就是在消息的传输过程中保存消息的队列。</p>
<h5 id="消息队列三大作用"><a href="#消息队列三大作用" class="headerlink" title="消息队列三大作用"></a>消息队列三大作用</h5><ul>
<li>解耦</li>
<li>异步</li>
<li>削峰(限流)</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC中各层次关系</title>
    <url>/2021/07/07/java-springmvc/</url>
    <content><![CDATA[<p>Spring MVC属于SpringFrameWork的后续产品， Spring 提供的一个基于 MVC 设计模式的轻量级 Web 开发框架，本质上相当于 Servlet，是后端开发人员必须掌握的一种模式，以下是我对各层次之间的理解。</p>
<span id="more"></span>

<h5 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h5><p>Dao层主要做数据持久层的工作，负责与数据库进行联络的一些任务都封装在此，Dao层的设计首先是设计Dao层的接口，然后在Spring的配置文件中定义此接口的实现类，然后就可以再模块中调用此接口来进行数据业务的处理，而不用关心此接口的具体实现类是哪个类，显得结构非常清晰，Dao层的数据源配置，以及有关数据库连接参数都在Spring配置文件中进行配置。</p>
<h5 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h5><p>Service层主要负责业务模块的应用逻辑应用设计。同样是首先设计接口，再设计其实现类，接着再Spring的配置文件中配置其实现的关联。这样我们就可以在应用中调用Service接口来进行业务处理。Service层的业务实，具体要调用已经定义的Dao层接口，封装Service层业务逻辑有利于通用的业务逻辑的独立性和重复利用性。程序显得非常简洁。</p>
<h5 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h5><p>Controller层负责具体的业务模块流程的控制，在此层要调用Service层的接口来控制业务流程，控制的配置也同样是在Spring的配置文件里进行，针对具体的业务流程，会有不同的控制器。我们具体的设计过程可以将流程进行抽象归纳，设计出可以重复利用的子单元流程模块。这样不仅使程序结构变得清晰，也大大减少了代码量。</p>
<h5 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h5><p>Service层是建立在Dao层之上的，建立了Dao层后才可以建立Service层，而Service层又是在Controller层之下的，因而Service层应该既调用Dao层的接口，又要提供接口给Controller层的类来进行调用，它刚好处于一个中间层的位置。每个模型都有一个Service接口，每个接口分别封装各自的业务处理方法。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux安装OpenJDK</title>
    <url>/2023/11/24/linux-openjdk/</url>
    <content><![CDATA[<p>由于CentOS已停止更新优先建议使用Debian 11及以上操作系统，如需使用CentOS请采用CentOS 7.9，本次安装采用Debian系统。</p>
<span id="more"></span>

<h2 id="1-JDK下载"><a href="#1-JDK下载" class="headerlink" title="1. JDK下载"></a>1. JDK下载</h2><p>OpenJDK下载：<a href="https://adoptium.net/zh-CN/temurin/releases/?version=8">官方地址</a></p>
<p>选择Linux对应版本进行下载 正常情况下载的文件名类似<code>OpenJDK8U-jdk_x64_linux_hotspot_\*.tar.gz</code></p>
<h2 id="2-安装准备"><a href="#2-安装准备" class="headerlink" title="2. 安装准备"></a>2. 安装准备</h2><h3 id="2-1-更新操作系统"><a href="#2-1-更新操作系统" class="headerlink" title="2.1 更新操作系统"></a>2.1 更新操作系统</h3><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">apt update &amp;&amp; apt install vim -y &amp;&amp; apt install zip -y &amp;&amp; apt install unzip -y<br></code></pre></td></tr></table></figure>

<h3 id="2-2-创建目录"><a href="#2-2-创建目录" class="headerlink" title="2.2 创建目录"></a>2.2 创建目录</h3><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> -p /data<br></code></pre></td></tr></table></figure>

<h3 id="2-3-上传文件"><a href="#2-3-上传文件" class="headerlink" title="2.3 上传文件"></a>2.3 上传文件</h3><p>将下载好的JDK，上传文件至<code>/data</code>目录下</p>
<h3 id="2-4-解压文件"><a href="#2-4-解压文件" class="headerlink" title="2.4 解压文件"></a>2.4 解压文件</h3><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 解压JDK并重命名</span><br><span class="hljs-built_in">cd</span> /data/ &amp;&amp; <span class="hljs-built_in">mkdir</span> -p /data/jdk &amp;&amp; tar -xzvf OpenJDK*.tar.gz -C /data/jdk --strip-components 1 &amp;&amp; <span class="hljs-built_in">rm</span> -rf OpenJDK*.tar.gz<br></code></pre></td></tr></table></figure>

<h2 id="3-安装JDK"><a href="#3-安装JDK" class="headerlink" title="3. 安装JDK"></a>3. 安装JDK</h2><h3 id="3-1-配置JDK环境变量"><a href="#3-1-配置JDK环境变量" class="headerlink" title="3.1 配置JDK环境变量"></a>3.1 配置JDK环境变量</h3><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;export JAVA_HOME=/data/jdk</span><br><span class="hljs-string">export CLASSPATH=.:\$JAVA_HOME/jre/lib/rt.jar:\$JAVA_HOME/lib/dt.jar:\$JAVA_HOME/lib/tools.jar</span><br><span class="hljs-string">export PATH=\$PATH:\$JAVA_HOME/bin&quot;</span> &gt;&gt; /etc/profile<br></code></pre></td></tr></table></figure>

<h3 id="3-2-更新配置文件并验证版本"><a href="#3-2-更新配置文件并验证版本" class="headerlink" title="3.2 更新配置文件并验证版本"></a>3.2 更新配置文件并验证版本</h3><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">source</span> /etc/profile &amp;&amp; java -version<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>OpenJDK</tag>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux安装Redis</title>
    <url>/2023/11/25/linux-redis/</url>
    <content><![CDATA[<p>Redis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。下面详细记录在Linux服务器下安装Redis的过程。</p>
<span id="more"></span>

<h2 id="1-Redis下载"><a href="#1-Redis下载" class="headerlink" title="1. Redis下载"></a>1. Redis下载</h2><p>Linux上下载Reids的方式有很多种，可以通过电脑下载好压缩包上传至Linux服务器，也可以直接通过<code>wget</code>命令直接在Liunx服务器上进行下载。本次安装的是redis官方最新版本，若需其它版本 可以进入 <a href="https://redis.io/">Redis官网</a>查看其他版本。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">wget http://download.redis.io/releases/redis-6.0.6.tar.gz<br></code></pre></td></tr></table></figure>

<h2 id="2-安装准备"><a href="#2-安装准备" class="headerlink" title="2. 安装准备"></a>2. 安装准备</h2><h3 id="2-1-解压并安装"><a href="#2-1-解压并安装" class="headerlink" title="2.1 解压并安装"></a>2.1 解压并安装</h3><p>解压后到解压根目录下的<code>src</code>中执行安装命令。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">tar -zxvf redis-6.0.6.tar.gz &amp;&amp; make<br></code></pre></td></tr></table></figure>

<h2 id="3-运行服务"><a href="#3-运行服务" class="headerlink" title="3. 运行服务"></a>3. 运行服务</h2><p>等着编译完成后，执行ls 命令，会看到src目录下多了些启动文件，进入src目录，执行启动命令启动服务。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">./redis-server<br></code></pre></td></tr></table></figure>

<h2 id="4-其他配置"><a href="#4-其他配置" class="headerlink" title="4. 其他配置"></a>4. 其他配置</h2><h3 id="4-1-后台启动"><a href="#4-1-后台启动" class="headerlink" title="4.1 后台启动"></a>4.1 后台启动</h3><p>通过上述步骤，已经可以实现Reids的正常运行，但是在我们关闭了命令窗口或者退出了服务器，服务就自动关闭。这样在实际情况下是不行的，必须保持后台运行，对此我们要进行如下操作，修改<code>redis.conf</code>文件。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">vim redis.conf<br></code></pre></td></tr></table></figure>

<p>将<code>daemonize no</code>改为&#x3D;&gt;<code>daemonize yes</code>操作完之后，就重新执行启动命令启动服务即可。</p>
<h3 id="4-3-配置redis-cli指令"><a href="#4-3-配置redis-cli指令" class="headerlink" title="4.3 配置redis-cli指令"></a>4.3 配置redis-cli指令</h3><p>将redis-cli,redis-server拷贝到bin下，让redis-cli指令可以在任意目录下直接使用</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cp</span> /usr/local/redis/bin/redis-server /usr/local/bin/<br><br><span class="hljs-built_in">cp</span> /usr/local/redis/bin/redis-cli /usr/local/bin/<br></code></pre></td></tr></table></figure>

<h3 id="4-2-设置redis密码"><a href="#4-2-设置redis密码" class="headerlink" title="4.2 设置redis密码"></a>4.2 设置redis密码</h3><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">redis-cli<br><br><span class="hljs-comment">#查看密码</span><br>config get requirepass<br><br><span class="hljs-comment">#设置密码</span><br>config <span class="hljs-built_in">set</span> requirepass yourpassword<br></code></pre></td></tr></table></figure>

<h3 id="4-3-外网访问redis"><a href="#4-3-外网访问redis" class="headerlink" title="4.3 外网访问redis"></a>4.3 外网访问redis</h3><p>首先进行配置防火墙,开放6379端口</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">firewall-cmd --zone=public --add-port=6379/tcp --permanent<br></code></pre></td></tr></table></figure>

<p>重启防火墙以使配置即时生效</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">systemctl restart firewalld<br></code></pre></td></tr></table></figure>

<p>查看系统所有开放的端口</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">firewall-cmd --zone=public --list-ports<br></code></pre></td></tr></table></figure>

<h3 id="4-4-可能会遇到的问题"><a href="#4-4-可能会遇到的问题" class="headerlink" title="4.4 可能会遇到的问题"></a>4.4 可能会遇到的问题</h3><p>可能开放端口后依旧无法访问，原因是虽然防火墙开放了6379端口，但是外网还是无法访问的，因为redis监听的是127.0.0.1:6379，并不监听外网的请求。这时候需要这样做。</p>
<ul>
<li>把文件夹目录里的redis.conf配置文件里的bind 127.0.0.1前面加#注释掉</li>
<li>redis-cli连接到redis后，通过 <code>config get daemonize</code>和<code>config get protected-mode</code> 是不是都为no，如果不是，就用<code>config set 配置名 属性</code> 改为no。</li>
</ul>
<h2 id="5-常用命令"><a href="#5-常用命令" class="headerlink" title="5. 常用命令"></a>5. 常用命令</h2><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#启动</span><br>./redis/src/redis-server redis.conf<br><br><span class="hljs-comment">#停止</span><br><span class="hljs-built_in">kill</span> -9 pid值  或者 ./redis-cli shutdown<br><br><span class="hljs-comment">#查看服务</span><br>ps aux|grep redis<br><br><span class="hljs-comment">#客户端连接</span><br>./redis-cli -h 127.0.0.1 -p 6379<br><br><span class="hljs-comment">#检测6379端口是否在监听</span><br>netstat -lntp | grep 6379<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis级联查询</title>
    <url>/2021/09/08/mybatis/</url>
    <content><![CDATA[<p>要实现级联查询必须以内嵌对象的方式进行关联，而不能仅关联主键，仅关联主键是无法做到级联查询的，但我们在开发中往往采用的就是仅关联主键</p>
<span id="more"></span>

<h4 id="什么时候需要使用级联查询？"><a href="#什么时候需要使用级联查询？" class="headerlink" title="什么时候需要使用级联查询？"></a>什么时候需要使用级联查询？</h4><p>要实现级联查询必须以内嵌对象的方式进行关联，而不能仅关联主键，仅关联主键是无法做到级联查询的，但我们在开发中往往采用的就是仅关联主键，也就是说级联查询在开发中其实用到的并不多。级联是在resultMap标签中配置。级联不是必须的，级联的好处是获取关联数据十分便捷，但是级联过多会增加系统的复杂度，同时降低系统的性能，次增彼减，所以记录超过3层时，就不要考虑使用级联了，因为这样会造成多个对象的关联，导致系统的耦合、负载和难以维护。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Lock</span> &#123;<br>	<span class="hljs-keyword">private</span> Integer id;<br>	<span class="hljs-keyword">private</span> String lockName;<br>	<span class="hljs-keyword">private</span> Key key;<span class="hljs-comment">//内嵌对象的方式关联对象</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="MyBatis中的级联分2种："><a href="#MyBatis中的级联分2种：" class="headerlink" title="MyBatis中的级联分2种："></a>MyBatis中的级联分2种：</h4><p>1.一对一（association）</p>
<p>2.一对多（collection）</p>
<h5 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h5><p>A表一对一B表情况下A对象当中有外键关联的B表的对象作为属性，A对象中有一个B对象属性。当查A对象时，如果想把B对象属性同时获取，有三种方式。</p>
<p>1、多表联合查询，即A表和B表联合查询，同事查出A、B表的字段，然后配置resultMap标签。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;AResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.A&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;A_ID&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;AId&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;INTEGER&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;ASSET_NO&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;assetNo&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;AREA_CODE&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;areaCode&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;A_ADDR&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">AAddr</span>&quot; <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 一下是对A对象中B的属性的映射配置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;B_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;b.BId&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;ONLINE_DATE&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;b.onlineDate&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;LAST_COMM_TIME&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;b.lastCommTime&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;STATUS_CODE&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;b.statusCode&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>2、多表联合查询，即A表和B表联合查询，同事查出A、B表的字段，然后通过association标签配置resultMap标签。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;AResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.A&quot;</span> &gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;A_ID&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;AId&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;INTEGER&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;ASSET_NO&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;assetNo&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;AREA_CODE&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;areaCode&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;A_ADDR&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">AAddr</span>&quot; <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span><br>  <span class="hljs-comment">&lt;!-- 一下是对A对象中B的属性的映射配置 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;b&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;com.B&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;B_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;bId&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;ONLINE_DATE&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;onlineDate&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;LAST_COMM_TIME&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;lastCommTime&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;STATUS_CODE&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;statusCode&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span> <br> <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>3、只查询A表字段，然后通过外键调用查询B表的select标签查询B表对象，通过association标签配置resultMap标签。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;AResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.A&quot;</span> &gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;A_ID&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;AId&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;INTEGER&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;ASSET_NO&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;assetNo&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;AREA_CODE&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;areaCode&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;A_ADDR&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">AAddr</span>&quot; <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span><br>  <span class="hljs-comment">&lt;!-- 一下是对A对象中B的属性的映射配置 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;b&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;B_ID&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;com.BMapper.selectBById&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>第三种方式只需要单表查询，但需要分别查询A表和B表，通过外键调用B表的select。association标签中调用的B表的select不通过BMapper的接口，因此在BMapper文件对应的接口中可以不写selectBById方法。</p>
<h5 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h5><p>1、B一对多A只需在resultMap标签中配置association标签即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;B&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getB&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;Bid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;Bid&quot;</span> /&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;AList&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;Bid&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;getAListByBid&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx正反向代理</title>
    <url>/2021/09/29/nginx/</url>
    <content><![CDATA[<p>Nginx是一款高性能的Web服务器软件，主要用于提供网上信息浏览服务，为高并发网站的应用场景而设计，可以在Linux、macOS和Windows等操作系统中运行。</p>
<span id="more"></span>

<h4 id="什么是Nginx？"><a href="#什么是Nginx？" class="headerlink" title="什么是Nginx？"></a>什么是Nginx？</h4><p>Nginx是一款高性能的Web服务器软件，主要用于提供网上信息浏览服务，为高并发网站的应用场景而设计，可以在Linux、macOS和Windows等操作系统中运行，它的优点包括性能高、稳定性好、结构模块化、配置简单以及资源消耗非常低等。拥有HTTPS访问、gzip压缩、虚拟主机和URL重写等功能，不但可以搭配FastCGI程序处理动态请求，还可以用于代理、反向代理、负载均衡和缓存服务器等功能。</p>
<h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h4><p>在如今的网络环境下，我们如果由于技术需要要去访问国外的某些网站，此时你会发现位于国外的某网站我们通过浏览器是没有办法访问的，此时大家可能都会用一个代理进行访问，代理的方式主要是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，代理服务器去访问国外的网站，然后将访问到的数据传递给我们！</p>
<p>上述这样的代理模式称为正向代理，正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。</p>
<p><img  src="/images/pic/detailed/zx.png"  ><span class="image-caption">正向代理</span></p>
<p>正向代理的用途：</p>
<ul>
<li>访问原来无法访问的资源，如Google</li>
<li>可以做缓存，加速访问资源</li>
<li>对客户端访问授权，上网进行认证</li>
<li>代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</li>
</ul>
<h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>反向代理和正向代理的区别就是：<code>正向代理代理客户端，反向代理代理服务器</code></p>
<p>反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。</p>
<p><img src="/images/pic/detailed/fx.png"></p>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>Nginx支持的负载均衡调度算法方式如下：</p>
<ul>
<li>weight轮询(默认)：接收到的请求按照顺序逐一分配到不同的后端服务器，即使在使用过程中，某一台后端服务器宕机，Nginx会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。 这种方式下，可以给不同的后端服务器设置一个权重值(weight)，用于调整不同的服务器上请求的分配率；权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的。</li>
<li>ip_hash：每个请求按照发起客户端的ip的hash结果进行匹配，这样的算法下一个固定ip地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下session共享的问题。</li>
<li>fair：智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配，响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少；结合了前两者的优点的一种调度算法。但是需要注意的是Nginx默认不支持fair算法，如果要使用这种调度算法，请安装upstream_fair模块。</li>
<li>url_hash：按照访问的url的hash结果分配请求，每个请求的url会指向后端固定的某个服务器，可以在Nginx作为静态服务器的情况下提高缓存效率。同样要注意Nginx默认不支持这种调度算法，要使用的话需要安装Nginx的hash软件包。</li>
</ul>
<h4 id="几种常用web服务器对比"><a href="#几种常用web服务器对比" class="headerlink" title="几种常用web服务器对比"></a>几种常用web服务器对比</h4><table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>Apache</strong></th>
<th><strong>Nginx</strong></th>
<th><strong>Lighttpd</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Proxy代理</td>
<td>非常好</td>
<td>非常好</td>
<td>一般</td>
</tr>
<tr>
<td>Rewriter</td>
<td>好</td>
<td>非常好</td>
<td>一般</td>
</tr>
<tr>
<td>Fcgi</td>
<td>不好</td>
<td>好</td>
<td>非常好</td>
</tr>
<tr>
<td>热部署</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>系统压力</td>
<td>很大</td>
<td>很小</td>
<td>比较小</td>
</tr>
<tr>
<td>稳定性</td>
<td>好</td>
<td>非常好</td>
<td>不好</td>
</tr>
<tr>
<td>安全性</td>
<td>好</td>
<td>一般</td>
<td>一般</td>
</tr>
<tr>
<td>静态文件处理</td>
<td>一般</td>
<td>非常好</td>
<td>好</td>
</tr>
<tr>
<td>反向代理</td>
<td>一般</td>
<td>非常好</td>
<td>一般</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>RESTful统一规范口</title>
    <url>/2021/07/07/restful/</url>
    <content><![CDATA[<p>RESTFUL是一种网络应用程序的设计风格和开发方式，基于HTTP，可以使用XML格式定义或JSON格式定义。RESTFUL适用于移动互联网厂商作为业务接口的场景，实现第三方OTT调用移动网络资源的功能，动作类型为新增、变更、删除所调用资源。</p>
<span id="more"></span>

<p><img src="/images/pic/detailed/restfui.png"></p>
<h4 id="1、GET"><a href="#1、GET" class="headerlink" title="1、GET"></a>1、GET</h4><ul>
<li>发送一个请求来获取服务器上某个资源，返回给客户端，包括HTTP头信息和数据。</li>
<li>安全且幂等</li>
<li>获取表示</li>
<li>变更时获取表示（缓存）</li>
<li>200（OK） - 表示已在响应中发出</li>
<li>204（无内容） - 资源有空表示</li>
<li>301（Moved Permanently） - 资源的URI已被更新</li>
<li>303（See Other） - 其他（如，负载均衡）</li>
<li>304（not modified）- 资源未更改（缓存）</li>
<li>400 （bad request）- 指代坏请求（如，参数错误）</li>
<li>404 （not found）- 资源不存在</li>
<li>406 （not acceptable）- 服务端不支持所需表示</li>
<li>500 （internal server error）- 通用错误响应</li>
<li>503 （Service Unavailable）- 服务端当前无法处理请求</li>
</ul>
<h4 id="2、POST"><a href="#2、POST" class="headerlink" title="2、POST"></a>2、POST</h4><ul>
<li><p>向服务器发送资源、不指定资源的存放位置，存放位置由服务器自己决定。</p>
</li>
<li><p>不安全且不幂等</p>
</li>
<li><p>使用服务端管理的（自动产生）的实例号创建资源</p>
</li>
<li><p>创建子资源</p>
</li>
<li><p>部分更新资源</p>
</li>
<li><p>如果没有被修改，则不过更新资源（乐观锁）</p>
</li>
<li><p>200（OK）- 如果现有资源已被更改</p>
</li>
<li><p>201（created）- 如果新资源被创建</p>
</li>
<li><p>202（accepted）- 已接受处理请求但尚未完成（异步处理）</p>
</li>
<li><p>301（Moved Permanently）- 资源的URI被更新</p>
</li>
<li><p>303（See Other）- 其他（如，负载均衡）</p>
</li>
<li><p>400（bad request）- 指代坏请求</p>
</li>
<li><p>404 （not found）- 资源不存在</p>
</li>
<li><p>406 （not acceptable）- 服务端不支持所需表示</p>
</li>
<li><p>409 （conflict）- 通用冲突</p>
</li>
<li><p>412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）</p>
</li>
<li><p>415 （unsupported media type）- 接受到的表示不受支持</p>
</li>
<li><p>500 （internal server error）- 通用错误响应</p>
</li>
<li><p>503 （Service Unavailable）- 服务当前无法处理请求</p>
</li>
</ul>
<h4 id="3、PUT"><a href="#3、PUT" class="headerlink" title="3、PUT"></a>3、PUT</h4><ul>
<li><p>向服务器发送资源，并指定资源的存放位置。</p>
</li>
<li><p>不安全但幂等</p>
</li>
<li><p>用客户端管理的实例号创建一个资源</p>
</li>
<li><p>通过替换的方式更新资源</p>
</li>
<li><p>如果未被修改，则更新资源（乐观锁）</p>
</li>
<li><p>200 （OK）- 如果已存在资源被更改</p>
</li>
<li><p>201 （created）- 如果新资源被创建</p>
</li>
<li><p>301（Moved Permanently）- 资源的URI已更改</p>
</li>
<li><p>303 （See Other）- 其他（如，负载均衡）</p>
</li>
<li><p>400 （bad request）- 指代坏请求</p>
</li>
<li><p>404 （not found）- 资源不存在</p>
</li>
<li><p>406 （not acceptable）- 服务端不支持所需表示</p>
</li>
<li><p>409 （conflict）- 通用冲突</p>
</li>
<li><p>412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）</p>
</li>
<li><p>415 （unsupported media type）- 接受到的表示不受支持</p>
</li>
<li><p>500 （internal server error）- 通用错误响应</p>
</li>
<li><p>503 （Service Unavailable）- 服务当前无法处理请求</p>
</li>
</ul>
<h4 id="4、DELETE"><a href="#4、DELETE" class="headerlink" title="4、DELETE"></a>4、DELETE</h4><ul>
<li><p>不安全但幂等</p>
</li>
<li><p>删除资源</p>
</li>
<li><p>200 （OK）- 资源已被删除</p>
</li>
<li><p>301 （Moved Permanently）- 资源的URI已更改</p>
</li>
<li><p>303 （See Other）- 其他，如负载均衡</p>
</li>
<li><p>400 （bad request）- 指代坏请求</p>
</li>
<li><p>404 （not found）- 资源不存在</p>
</li>
<li><p>409 （conflict）- 通用冲突</p>
</li>
<li><p>500 （internal server error）- 通用错误响应</p>
</li>
<li><p>503 （Service Unavailable）- 服务端当前无法处理请求</p>
</li>
</ul>
<h4 id="5、与数据库CRUD对应关系"><a href="#5、与数据库CRUD对应关系" class="headerlink" title="5、与数据库CRUD对应关系"></a>5、与数据库CRUD对应关系</h4><ul>
<li>Create——PUT——修改、更新</li>
<li>Read——GET——新建</li>
<li>Update——POST——更新、新建</li>
<li>Delete——DELETE——删除</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>restful</tag>
      </tags>
  </entry>
  <entry>
    <title>SpingIoc浅析</title>
    <url>/2021/09/10/springioc/</url>
    <content><![CDATA[<p>学习过Spring框架的人一定都会听过Spring的IoC(控制反转) 、DI(依赖注入)这两个概念，今天分享网上的一些技术大牛们对Spring框架的IOC的理解以及谈谈我对Spring Ioc的理解。</p>
<span id="more"></span>

<h4 id="IOC（控制反转）"><a href="#IOC（控制反转）" class="headerlink" title="IOC（控制反转）"></a>IOC（控制反转）</h4><p>首先是IoC，所谓控制反转，就是把原先我们代码里面需要实现的对象创建、依赖的代码，反转给容器来帮忙实现。那么必然的我们需要创建一个容器，同时需要一种描述来让容器知道需要创建的对象与对象的关系。这个描述最具体表现就是我们可配置的文件。即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</p>
<p><img  src="/images/pic/detailed/ioc.png"  ><span class="image-caption">ioc图</span></p>
<h4 id="DI（注入依赖）"><a href="#DI（注入依赖）" class="headerlink" title="DI（注入依赖）"></a>DI（注入依赖）</h4><p>IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。</p>
<h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>在平时的java应用开发中，我们要实现某一个功能或者说是完成某个业务逻辑时至少需要两个或以上的对象来协作完成，在没有使用Spring的时候，每个对象在需要使用他的合作对象时，自己均要使用像new object() 这样的语法来将合作对象创建出来，这个合作对象是由自己主动创建出来的，创建合作对象的主动权在自己手上，自己需要哪个合作对象，就主动去创建，创建合作对象的主动权和创建时机是由自己把控的，而这样就会使得对象间的耦合度高了，A对象需要使用合作对象B来共同完成一件事，A要使用B，那么A就对B产生了依赖，也就是A和B之间存在一种耦合关系，并且是紧密耦合在一起，而使用了Spring之后就不一样了，创建合作对象B的工作是由Spring来做的，Spring创建好B对象，然后存储到一个容器里面，当A对象需要使用B对象时，Spring就从存放对象的那个容器里面取出A要使用的那个B对象，然后交给A对象使用，至于Spring是如何创建那个对象，以及什么时候创建好对象的，A对象不需要关心这些细节问题(你是什么时候生的，怎么生出来的我可不关心，能帮我干活就行)，A得到Spring给我们的对象之后，两个人一起协作完成要完成的工作即可。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务间通信和RestTemplate</title>
    <url>/2021/08/08/template/</url>
    <content><![CDATA[<p>各种协议众多，那么在微服务中服务通信该如何进行通信呢？</p>
<span id="more"></span>

<h4 id="如何解决微服务的服务通信问题？"><a href="#如何解决微服务的服务通信问题？" class="headerlink" title="如何解决微服务的服务通信问题？"></a>如何解决微服务的服务通信问题？</h4><p>第一种: 服务间使用HTTP协议，调用rest风格的API进行数据传输（JSON）。（普遍使用）</p>
<p>第二种：服务间使用RPC协议，通过远程过程进行调用（二进制）。</p>
<p>总结：通过OSI七层模型（如下图）可以看出PRC（传输层）的传输效率远高于HTTP（应用层）。众所周知，在众多语言中不是全部都支持RPC协议但是基本都支持HTTP协议，所以服务之间的高度解耦，故Spring官方也推荐使用HTTP协议进行数据传输。</p>
<p><img  src="/images/pic/detailed/osi.png"  ><span class="image-caption">osi</span></p>
<h4 id="什么是RestTemplate？"><a href="#什么是RestTemplate？" class="headerlink" title="什么是RestTemplate？"></a>什么是RestTemplate？</h4><p>传统情况下在java代码里访问restful服务，一般使用<code>Apache</code>的<code>HttpClient</code>。不过此种方法使用起来太过繁琐。spring提供了一种简单便捷的模板类来进行操作，这就是<code>RestTemplate</code>。</p>
<h4 id="服务之间的简单调用"><a href="#服务之间的简单调用" class="headerlink" title="服务之间的简单调用"></a>服务之间的简单调用</h4><ul>
<li>A服务</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/Aservice&quot;)</span><br>	<span class="hljs-keyword">public</span> String <span class="hljs-title function_">Aservice</span><span class="hljs-params">()</span> &#123;<br>	  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;A service ok！！！&quot;</span>;<br>	&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>B服务</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/Bservice&quot;)</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">Bservice</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;B service ok！！！&quot;</span>;<br>  &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>在A服务调用B服务</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/Aservice&quot;)</span><br>	<span class="hljs-keyword">public</span> String <span class="hljs-title function_">Aservice</span><span class="hljs-params">()</span> &#123;<br>	  <span class="hljs-type">RestTemplate</span> <span class="hljs-variable">restTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>	  <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> restTemplate.getForObject(<span class="hljs-string">&quot;http://localhost:8888/api/user/Bservice&quot;</span>, String.class);<br>	  <span class="hljs-keyword">return</span> result+<span class="hljs-string">&quot;调用成功！！！&quot;</span>;<br>	&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows/Office安装与激活</title>
    <url>/2023/11/23/win-office-activation/</url>
    <content><![CDATA[<p>每次重装电脑系统，都会重新要求激活windows和office，具体如何激活呢？</p>
<span id="more"></span>

<h2 id="1-Windows激活"><a href="#1-Windows激活" class="headerlink" title="1. Windows激活"></a>1. Windows激活</h2><h3 id="1-1-Windows11下载地址"><a href="#1-1-Windows11下载地址" class="headerlink" title="1.1 Windows11下载地址"></a>1.1 Windows11下载地址</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">文件：zh-cn_windows_11_business_editions_version_23h2_x64_dvd_2a79e0f1.iso<br>大小：<span class="hljs-number">6</span>.<span class="hljs-number">16</span> GB<br>SHA256：B4F4CAA4BA52B4BCD59072D5361DBDB287856C48CE7C9EE39008DC294F3111DF<br>下载：ed2k://|file|zh-cn_windows_11_business_editions_version_23h2_x64_dvd_2a79e0f1.iso|<span class="hljs-number">6613571584</span>|<span class="hljs-number">1</span>AFADEBC5966E9E689F242549FFB5562|/<br>下载：magnet:?xt=urn:btih:b5fed4ee16b1c9b886f44dd30cd70fdf746f58f5&amp;dn=zh-cn_windows_11_business_editions_version_23h2_x64_dvd_2a79e0f1.iso&amp;xl=<span class="hljs-number">6613571584</span><br></code></pre></td></tr></table></figure>

<h3 id="1-2-软件激活"><a href="#1-2-软件激活" class="headerlink" title="1.2 软件激活"></a>1.2 软件激活</h3><p>推荐<code>HEU KMS Activator</code>软件进行数字权利永久激活。</p>
<p><img  src="/images/pic/detailed/WindowsOffice%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95.assets/image-20231123182150491.png"  ><span class="image-caption">image-20231123182150491</span></p>
<p>下载地址：<a href="https://liu.lanzouq.com/i3lRa1fr014j">HEU KMS Activator</a></p>
<h2 id="2-Office激活"><a href="#2-Office激活" class="headerlink" title="2. Office激活"></a>2. Office激活</h2><h3 id="2-1-office2021下载地址"><a href="#2-1-office2021下载地址" class="headerlink" title="2.1 office2021下载地址"></a>2.1 office2021下载地址</h3><blockquote>
<p><a href="https://officecdn.microsoft.com/db/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/ProPlus2021Retail.img">https://officecdn.microsoft.com/db/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/ProPlus2021Retail.img</a></p>
</blockquote>
<h3 id="2-2-软件激活"><a href="#2-2-软件激活" class="headerlink" title="2.2 软件激活"></a>2.2 软件激活</h3><p>推荐<code>HEU KMS Activator</code>软件进行一键激活。方法和与Windows激活方式相同。</p>
<h3 id="2-3-电话激活"><a href="#2-3-电话激活" class="headerlink" title="2.3 电话激活"></a>2.3 电话激活</h3><h4 id="2-3-1-获取密钥"><a href="#2-3-1-获取密钥" class="headerlink" title="2.3.1 获取密钥"></a>2.3.1 获取密钥</h4><p>例如：<code>N68B3-RH383-YV63M-RHTV9-P4BGK </code>获取途径暂不提供，网上有很多。</p>
<h4 id="2-3-2-获取确认ID"><a href="#2-3-2-获取确认ID" class="headerlink" title="2.3.2 获取确认ID"></a>2.3.2 获取确认ID</h4><p><img  src="/images/pic/detailed/WindowsOffice%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95.assets/05aadd63d37a4c7cb8eef567c9420f1.png"  ><span class="image-caption">05aadd63d37a4c7cb8eef567c9420f1</span></p>
<p>输入有效密钥后，即可看到安装ID，需要我们输入确认ID进行激活。一般获取确认ID的办法有两种，一种是在线计算，另外一种是打电话进行激活。</p>
<p>在线激活</p>
<blockquote>
<p>网页激活1：<a href="https://jihuo.ma/tool/mscid.html">https://jihuo.ma/tool/mscid.html</a></p>
<p>网页激活2：<a href="https://khoatoantin.com/cidms">https://khoatoantin.com/cidms</a> （用户名: trogiup24h 密码 : PHO）</p>
</blockquote>
<p>电话激活</p>
<blockquote>
<p>1.电信用户拨打8008301832（推荐）移动联通拨打4008301832</p>
<p>2.等待说中文或直接按1，按1（同意），按1（1，2随意），输入验证码，按1（选择Windows，不管激活什么产品一律按1），按2（一律按2否则），按1（已打开），输入安装ID，按1（副本数量）</p>
<p>3.等待说确认ID(可以忽略不用记下确认ID,重新用密钥激活一次)。</p>
</blockquote>
<h2 id="3-Office密钥卸载"><a href="#3-Office密钥卸载" class="headerlink" title="3. Office密钥卸载"></a>3. Office密钥卸载</h2><h3 id="3-1-打开PowerShell"><a href="#3-1-打开PowerShell" class="headerlink" title="3.1 打开PowerShell"></a>3.1 打开PowerShell</h3><p><img  src="/images/pic/detailed/WindowsOffice%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95.assets/image-20231123180622123.png"  ><span class="image-caption">image-20231123180622123</span></p>
<h3 id="3-2-输入查看命令"><a href="#3-2-输入查看命令" class="headerlink" title="3.2 输入查看命令"></a>3.2 输入查看命令</h3><p>输入如下命令，即可查看当前电脑中存在的密钥。红色部分即为产品名称以及密钥后5位数字。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">cscript &quot;C:\Program Files\Microsoft Office\Office16\ospp.vbs&quot; /dstatus<br></code></pre></td></tr></table></figure>

<p><img  src="/images/pic/detailed/WindowsOffice%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95.assets/image-20231123180830243.png"  ><span class="image-caption">image-20231123180830243</span></p>
<h3 id="3-3-卸载当前密钥"><a href="#3-3-卸载当前密钥" class="headerlink" title="3.3 卸载当前密钥"></a>3.3 卸载当前密钥</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">cscript &quot;C:\Program Files\Microsoft Office\Office16\ospp.vbs&quot; /unpkey:XXXXX <br></code></pre></td></tr></table></figure>

<blockquote>
<p>XXXXX是你想要卸载的产品的密钥后5位，即可卸载密钥。</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Office</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis常见问题</title>
    <url>/2021/07/07/java-mybatis-interview/</url>
    <content><![CDATA[<p>Mybatis是一个基于Java的持久层框架，在后端开发中起到巨大作用，同时也是面试官最喜欢问的版块之一，下面自己整理了关于Mybatis常见的一些问题</p>
<span id="more"></span>

<h5 id="什么是Mybatis？"><a href="#什么是Mybatis？" class="headerlink" title="什么是Mybatis？"></a>什么是Mybatis？</h5><ul>
<li>Mybatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发时 只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制 sql 执行性 能，灵活度高。</li>
<li>MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成数 据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</li>
<li>通过 xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句，最 后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。（从执行 sql 到返 回 result 的过程）</li>
</ul>
<h5 id="MyBatis-的优点"><a href="#MyBatis-的优点" class="headerlink" title="MyBatis 的优点"></a>MyBatis 的优点</h5><ul>
<li>基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任 何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML 标签，支持编写动态 SQL 语句，并可重用。</li>
<li>与 JDBC 相比，减少了 50%以上的代码量，消除了 JDBC 大量冗余的代码，不 需要手动开关连接；</li>
<li>很好的与各种数据库兼容（因为 MyBatis 使用 JDBC 来连接数据库，所以只要 JDBC 支持的数据库 MyBatis 都支持）。</li>
<li>能够与 Spring 很好的集成；</li>
<li>提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射 标签，支持对象关系组件维护。</li>
</ul>
<h5 id="MyBatisde-的缺点"><a href="#MyBatisde-的缺点" class="headerlink" title="MyBatisde 的缺点"></a>MyBatisde 的缺点</h5><ul>
<li>SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写 SQL 语句的功底有一定要求。</li>
<li>SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</li>
</ul>
<h5 id="MyBatis-框架适用场合"><a href="#MyBatis-框架适用场合" class="headerlink" title="MyBatis 框架适用场合"></a>MyBatis 框架适用场合</h5><ul>
<li>MyBatis 专注于 SQL 本身，是一个足够灵活的 DAO 层解决方案。</li>
<li>对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis 将是 不错的选择</li>
</ul>
<h5 id="MyBatis-与-Hibernate-有哪些不同？"><a href="#MyBatis-与-Hibernate-有哪些不同？" class="headerlink" title="MyBatis 与 Hibernate 有哪些不同？"></a>MyBatis 与 Hibernate 有哪些不同？</h5><ul>
<li>Mybatis 和 hibernate 不同，它不完全是一个 ORM 框架，因为 MyBatis 需要 程序员自己编写 Sql 语句</li>
<li>Mybatis 直接编写原生态 sql，可以严格控制 sql 执行性能，灵活度高，非常 适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需 求变化要求迅速输出成果。但是灵活的前提是 mybatis 无法做到数据库无关性， 如果需要实现支持多种数据库的软件，则需要自定义多套 sql 映射文件，工作量大。</li>
<li>Hibernate 对象&#x2F;关系映射能力强，数据库无关性好，对于关系模型要求高的 软件，如果用 hibernate 开发可以节省很多代码，提高效率。</li>
</ul>
<h5 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h5><ul>
<li><code>#&#123;&#125;</code>是预编译处理，<code>$&#123;&#125;</code>是字符串替换。</li>
<li>Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的 set 方法来赋值；</li>
<li><code>Mybatis 在处理</code>{}时，就是把${}替换成变量的值。</li>
<li>使用#{}可以有效的防止 SQL 注入，提高系统安全性。</li>
</ul>
<p>第 1 种：通过在查询的 sql 语句中定义字段名的别名，让字段名的别名和实体类 的属性名一致</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”selectorder”</span> <span class="hljs-attr">parametertype</span>=<span class="hljs-string">”int”</span> <span class="hljs-attr">resultetype</span>=<span class="hljs-string">”me.gacl.domain.order”</span>&gt;</span><br>        select order_id id, order_no orderno ,order_price price form<br>        orders where order_id=#&#123;id&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>第 2 种：通过来映射字段名和实体类属性名的一一对应的关系。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getOrder&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span>  <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;orderresultmap&quot;</span>&gt;</span><br>    select * from orders where order_id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">”me.gacl.domain.order”</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”orderresultmap”</span>&gt;</span><br>&lt;!–用 id 属性来映射主键字段–&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">”id”</span> <span class="hljs-attr">column</span>=<span class="hljs-string">”order_id”</span>&gt;</span><br>&lt;!–用 result 属性来映射非主键字段，property 为实体类属性名，column<br>        为数据表中的属性–&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span> = <span class="hljs-string">“orderno”</span> <span class="hljs-attr">column</span> =<span class="hljs-string">”order_no”/</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">”price”</span> <span class="hljs-attr">column</span>=<span class="hljs-string">”order_price”</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">reslutMap</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h5 id="模糊查询-like-语句该怎么写"><a href="#模糊查询-like-语句该怎么写" class="headerlink" title="模糊查询 like 语句该怎么写?"></a>模糊查询 like 语句该怎么写?</h5><p>第 1 种：在 Java 代码中添加 sql 通配符。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">string wildcardname = “%smi%”;<br>        list<span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span> names = mapper.selectlike(wildcardname);<br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”selectlike”</span>&gt;</span><br>    select * from foo where bar like #&#123;value&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>第 2 种：在 sql 语句中拼接通配符，会引起 sql 注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">string wildcardname = “smi”;<br>        list<span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span> names = mapper.selectlike(wildcardname);<br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”selectlike”</span>&gt;</span><br>    select * from foo where bar like &quot;%&quot;#&#123;value&#125;&quot;%&quot;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h5 id="Mapper-接口的工作原理是什么？Mapper-接口里的方法，参数不同时，方法能重载吗？"><a href="#Mapper-接口的工作原理是什么？Mapper-接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="Mapper 接口的工作原理是什么？Mapper 接口里的方法，参数不同时，方法能重载吗？"></a>Mapper 接口的工作原理是什么？Mapper 接口里的方法，参数不同时，方法能重载吗？</h5><ul>
<li><p>Dao 接口即 Mapper 接口。接口的全限名，就是映射文件中的 namespace 的值；接口的方法名，就是映射文件中 Mapper 的 Statement 的 id 值；接口方法内的参数，就是传递给 sql 的参数。</p>
</li>
<li><p>Mapper 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个 MapperStatement。在 Mybatis 中，每一个 <code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code>标签，都会被解析为一个MapperStatement 对象。</p>
</li>
<li><p>举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到 namespace 为com.mybatis3.mappers.StudentDao 下面 id 为findStudentById 的 MapperStatement。</p>
</li>
<li><p>Mapper 接口里的方法，是不能重载的，因为是使用 全限名+方法名 的保存和寻找策略。Mapper 接口的工作原理是 JDK 动态代理，Mybatis 运行时会使用 JDK动态代理为 Mapper 接口生成代理对象 proxy，代理对象会拦截接口方法，转而执行 MapperStatement 所代表的 sql，然后将 sql 执行结果返回。</p>
</li>
</ul>
<h5 id="Mybatis-是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis 是如何进行分页的？分页插件的原理是什么？"></a>Mybatis 是如何进行分页的？分页插件的原理是什么？</h5><ul>
<li><p>Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页。可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p>
</li>
<li><p>分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p>
</li>
</ul>
<h5 id="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h5><ul>
<li><p>第一种是使用标签，逐一定义数据库列名和对象属性名之间的映射关系。</p>
</li>
<li><p>第二种是使用 sql 列的别名功能，将列的别名书写为对象属性名。</p>
</li>
<li><p>有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
</li>
</ul>
<h5 id="如何执行批量插入"><a href="#如何执行批量插入" class="headerlink" title="如何执行批量插入?"></a>如何执行批量插入?</h5><p>首先,创建一个简单的 insert 语句:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”insertname”</span>&gt;</span><br>    insert into names (name) values (#&#123;value&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>然后在 java 代码中像下面这样执行批处理插入:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">list &lt; string &gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">arraylist</span>();<br>names.add(“fred”);<br>names.add(“barney”);<br>names.add(“betty”);<br>names.add(“wilma”);<br><span class="hljs-comment">// 注意这里 executortype.batch</span><br><span class="hljs-type">sqlsession</span> <span class="hljs-variable">sqlsession</span> <span class="hljs-operator">=</span><br>sqlsessionfactory.opensession(executortype.batch);<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">namemapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlsession.getmapper(namemapper.class);<br>    <span class="hljs-keyword">for</span> (string name: names) &#123;<br>        mapper.insertname(name);<br>    &#125;<br>    sqlsession.commit();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>    sqlSession.rollback();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    sqlsession.close();<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="如何获取自动生成的-主-键值"><a href="#如何获取自动生成的-主-键值" class="headerlink" title="如何获取自动生成的(主)键值?"></a>如何获取自动生成的(主)键值?</h5><ul>
<li><p>insert 方法总是返回一个 int 值 ，这个值代表的是插入的行数。</p>
</li>
<li><p>如果采用自增长策略，自动生成的键值在 insert 方法执行完后可以被设置到传入 的参数对象中。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”insertname”</span> <span class="hljs-attr">usegeneratedkeys</span>=<span class="hljs-string">”true”</span> <span class="hljs-attr">keyproperty</span>=<span class="hljs-string">”id”</span>&gt;</span><br>    insert into names (name) values (#&#123;name&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br>name name = new name();<br>name.setname(“fred”);<br>int rows = mapper.insertname(name);<br>// 完成后,id 已经被设置到对象中<br>system.out.println(“rows inserted = ” + rows);<br>system.out.println(“generated key value = ” + name.getid());<br></code></pre></td></tr></table></figure>

<h5 id="在-mapper-中如何传递多个参数"><a href="#在-mapper-中如何传递多个参数" class="headerlink" title="在 mapper 中如何传递多个参数?"></a>在 mapper 中如何传递多个参数?</h5><p>第一种：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">public UserselectUser(String name,String area);<br>对应的 xml,#&#123;0&#125;代表接收的是 dao 层中的第一个参数，#&#123;1&#125;代表 dao 层中第二<br>参数，更多参数一致往后加即可。<br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span><span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span>&gt;</span><br>    select * fromuser_user_t<br>    whereuser_name = #&#123;0&#125;<br>    anduser_area=#&#123;1&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>第二种：使用 @param 注解:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">usermapper</span> &#123;<br><br>    user <span class="hljs-title function_">selectuser</span><span class="hljs-params">(<span class="hljs-meta">@param(“username”)</span> string username,<span class="hljs-meta">@param(“hashedpassword”)</span> string hashedpassword)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后,就可以在 xml 像下面这样使用(推荐封装为一个 map,作为单个参数传递给(mapper)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”selectuser”</span> <span class="hljs-attr">resulttype</span>=<span class="hljs-string">”user”</span>&gt;</span><br>    select id, username, hashedpassword<br>    from some_table<br>    where username = #&#123;username&#125;<br>    and hashedpassword = #&#123;hashedpassword&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>第三种：多个参数封装成 map</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//映射文件的命名空间.SQL 片段的 ID，就可以调用对应的映射文件中的 SQL</span><br>    <span class="hljs-comment">//由于我们的参数超过了两个，而方法中只有一个 Object 参数收集，因此</span><br>    我们使用 Map 集合来装载我们的参数<br>    Map &lt; String, Object &gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>    map.put(<span class="hljs-string">&quot;start&quot;</span>, start);<br>    map.put(<span class="hljs-string">&quot;end&quot;</span>, end);<br>    <span class="hljs-keyword">return</span> sqlSession.selectList(<span class="hljs-string">&quot;StudentID.pagination&quot;</span>, map);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>    sqlSession.rollback();<br>    <span class="hljs-keyword">throw</span> e;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    MybatisUtil.closeSqlSession();<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="Mybatis-动态-sql-有什么用？执行原理？有哪些动态-sql？"><a href="#Mybatis-动态-sql-有什么用？执行原理？有哪些动态-sql？" class="headerlink" title="Mybatis 动态 sql 有什么用？执行原理？有哪些动态 sql？"></a>Mybatis 动态 sql 有什么用？执行原理？有哪些动态 sql？</h5><ul>
<li><p>Mybatis 动态 sql 可以在 Xml 映射文件内，以标签的形式编写动态 sql，执行原理 是根据表达式的值 完成逻辑判断并动态拼接 sql 的功能。</p>
</li>
<li><p>Mybatis 提供了 9 种动态 sql 标签：trim | where | set | foreach | if | choose | when | otherwise | bind。</p>
</li>
</ul>
<h5 id="Xml-映射文件中，除了常见的-select-insert-updae-delete-标签之外，还有哪些标签？"><a href="#Xml-映射文件中，除了常见的-select-insert-updae-delete-标签之外，还有哪些标签？" class="headerlink" title="Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？"></a>Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？</h5><ul>
<li><code>&lt;resultMap&gt;</code>、<code>&lt;parameterMap&gt;</code>、<code>&lt;sql&gt;</code>、<code>&lt;include&gt;</code>、<code>&lt;selectKey&gt;</code>，加上动态 sql 的 9 个标签，其中为 sql 片段标签，通过标签引入 sql 片段，为不支持自增的主键生成策略标签。</li>
</ul>
<h5 id="Mybatis-的-Xml-映射文件中，不同的-Xml-映射文件，id-是否可以重复？"><a href="#Mybatis-的-Xml-映射文件中，不同的-Xml-映射文件，id-是否可以重复？" class="headerlink" title="Mybatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？"></a>Mybatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？</h5><ul>
<li><p>不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复；</p>
</li>
<li><p>原因就是 namespace+id 是作为 Map的 key使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然也就不同。</p>
</li>
<li><p>为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？<br>Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 Mybatis在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。</p>
</li>
</ul>
<h5 id="一对一、一对多的关联查询-？"><a href="#一对一、一对多的关联查询-？" class="headerlink" title="一对一、一对多的关联查询 ？"></a>一对一、一对多的关联查询 ？</h5><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.lcb.mapping.userMapper&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--association 一对一关联查询 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getClass&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;ClassesResultMap&quot;</span>&gt;</span><br>        select * from class c,teacher t where c.teacher_id=t.t_id and<br>        c.c_id=#&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.lcb.user.Classes&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ClassesResultMap&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 实体类的字段名和数据表的字段名映射 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;c_id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;c_name&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;com.lcb.user.Teacher&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;t_id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;t_name&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--collection 一对多关联查询 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getClass2&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;ClassesResultMap2&quot;</span>&gt;</span><br>        select * from class c,teacher t,student s where c.teacher_id=t.t_id<br>        and c.c_id=s.class_id and c.c_id=#&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.lcb.user.Classes&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ClassesResultMap2&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;c_id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;c_name&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;com.lcb.user.Teacher&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;t_id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;t_name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;com.lcb.user.Student&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;s_id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;s_name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h5 id="MyBatis-实现一对一有几种方式-具体怎么操作的？"><a href="#MyBatis-实现一对一有几种方式-具体怎么操作的？" class="headerlink" title="MyBatis 实现一对一有几种方式?具体怎么操作的？"></a>MyBatis 实现一对一有几种方式?具体怎么操作的？</h5><ul>
<li><p>有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次, 通过在resultMap 里面配置 association 节点配置一对一的类就可以完成；</p>
</li>
<li><p>嵌套查询是先查一个表，根据这个表里面的结果的 外键 id，去再另外一个表里面查询数据,也是通过 association 配置，但另外一个表的查询通过 select 属性配置。</p>
</li>
</ul>
<h5 id="Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h5><ul>
<li><p>Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加 载，association 指的就是一对一，collection 指的就是一对多查询。在 Mybatis 配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled&#x3D;true|false。</p>
</li>
<li><p>它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p>
</li>
<li><p>当然了，不光是 Mybatis，几乎所有的包括 Hibernate，支持延迟加载的原理都是一样的。</p>
</li>
<li><p>Mybatis 的一级、二级缓存<br>1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就 将清空，默认打开一级缓存。</p>
<p>2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态),可在它的映射文件中配置；</p>
<p>3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)的进行了 C&#x2F;U&#x2F;D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>
</li>
</ul>
<h5 id="什么是-MyBatis-的接口绑定？有哪些实现方式？"><a href="#什么是-MyBatis-的接口绑定？有哪些实现方式？" class="headerlink" title="什么是 MyBatis 的接口绑定？有哪些实现方式？"></a>什么是 MyBatis 的接口绑定？有哪些实现方式？</h5><ul>
<li><p>接口绑定，就是在 MyBatis 中任意定义接口,然后把接口里面的方法和 SQL 语句绑定, 我们直接调用接口方法就可以,这样比起原来了 SqlSession 提供的方法我们可以有更加灵活的选择和设置。</p>
</li>
<li><p>接口绑定有两种实现方式,一种是通过注解绑定，就是在接口的方法上面加上@Select、@Update 等注解，里面包含 Sql 语句来绑定；另外一种就是通过 xml里面写 SQL 来绑定, 在这种情况下,要指定 xml 映射文件里面的 namespace 必须为接口的全路径名。当 Sql 语句比较简单时候,用注解绑定, 当 SQL 语句比较复杂时候,用 xml 绑定,一般用 xml 绑定的比较多。</p>
</li>
</ul>
<h5 id="使用-MyBatis-的-mapper-接口调用时有哪些要求？"><a href="#使用-MyBatis-的-mapper-接口调用时有哪些要求？" class="headerlink" title="使用 MyBatis 的 mapper 接口调用时有哪些要求？"></a>使用 MyBatis 的 mapper 接口调用时有哪些要求？</h5><ul>
<li>Mapper 接口方法名和 mapper.xml 中定义的每个 sql 的 id 相同；</li>
<li>Mapper 接口方法的输入参数类型和 mapper.xml 中定义的每个 sql 的 parameterType 的类型相同；</li>
<li>Mapper 接口方法的输出参数类型和 mapper.xml 中定义的每个 sql 的 resultType 的类型相同；</li>
<li>Mapper.xml 文件中的 namespace 即是 mapper 接口的类路径。</li>
</ul>
<h5 id="简述-Mybatis-的插件运行原理，以及如何编写一个插件"><a href="#简述-Mybatis-的插件运行原理，以及如何编写一个插件" class="headerlink" title="简述 Mybatis 的插件运行原理，以及如何编写一个插件"></a>简述 Mybatis 的插件运行原理，以及如何编写一个插件</h5><ul>
<li><p>答：Mybatis 仅可以编写针对 ParameterHandler、ResultSetHandler、StatementHandler、Executor 这 4 种接口的插件，Mybatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</p>
</li>
<li><p>编写插件：实现 Mybatis 的 Interceptor 接口并复写 intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
</search>
